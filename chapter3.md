在本章中，我们将描述PDF文件的四个主要部分的布局和内容，
以及构成每个部分的对象的语法。 我们还概述了将PDF文件读入
高级数据结构的过程，以及将该结构写入PDF文件的相反操作。

## File 布局
一个简单有效的PDF文件按顺序包含四个部分：
* 1. *header*，提供PDF版本号
* 2. 包含页面，图形内容和大部分辅助信息的主体，全部编码为一系列对象。
* 3. 交叉引用表，列出文件中每个对象的位置便于随机访问。
* 4. trailer包括trailer字典，它有助于找到文件的每个部分，并列出可以在不处理整个文件的情况下读取的各种元数据。

作为参考，我们从第2章再现“Hello，World”PDF作为例3-1。
四个部分中的每一部分的第一行都有注释。
Example 3-1. A small PDF file
```
%PDF-1.0 Header从这里开始
%âãÏÓ
1 0 obj Body从这里开始
<<
/Kids [2 0 R]
/Count 1
/Type /Pages
>>
endobj
2 0 obj
<<
25
/Rotate 0
/Parent 1 0 R
/Resources 3 0 R
/MediaBox [0 0 612 792]
/Contents [4 0 R]
/Type /Page
>>
endobj
3 0 obj
<<
/Font
<<
/F0
<<
/BaseFont /Times-Italic
/Subtype /Type1
/Type /Font
>>
>>
>>
endobj
4 0 obj
<<
/Length 65
>>
stream
1. 0. 0. 1. 50. 700. cm
BT
 /F0 36. Tf
 (Hello, World!) Tj
ET
endstream
endobj
5 0 obj
<<
/Pages 1 0 R
/Type /Catalog
>>
endobj
xref Cross-reference table从这里开始
0 6
0000000000 65535 f
0000000015 00000 n
0000000074 00000 n
0000000192 00000 n
0000000291 00000 n
0000000409 00000 n
trailer Trailer从这里开始
<<
/Root 5 0 R
/Size 6
>>
startxref
459
%%EOF

```
PDF文件中的对象集合形成图形。这个词图的意思
与饼图或直方图无关，而是指通过链接连接在一起的节点集合。

在我们的例子中，节点是PDF对象，链接是间接引用。 读一个
PDF文档是在文件中创建PDF对象的图形的过程。 这个
图是直接链接只走一条路。

我们现在依次仔细研究这四个部分中的每一个，使用例3-1作为参考。

### Header
PDF文件的第一行给出文档的版本号。 在我们的示例中，是：
```
%PDF-1.0
```
这将文件定义为PDF版本1.0。 PDF是向后兼容的，因此PDF 1.3文档
应该由知道例如PDF 1.5的程序读取。它在很大程度上也是向前兼容的，
因此大多数PDF程序都会尝试读取任何文件，无论假设的版本号是什么。

由于PDF文件几乎总是包含二进制数据，因此如果更改行结尾
（例如，如果文件通过FTP以文本模式传输），它们可能会损坏。
 为了允许传统文件传输程序确定文件是二进制文件，
 通常在标头中包含一些字符代码高于127的字节。 例如：
 ```
%âãÏÓ
```
百分号表示另一个标题行，其他几个字节是超过127的任意字符代码。
因此，我们示例中的整个header是：
```
%PDF-1.0
%âãÏÓ
```

### Body
文件正文由一系列对象组成，每个对象在一行上都有一个对象编号，
世代号和obj关键字，在另一行之后是endobj关键字。 例如：
```
1 0 obj
<<
/Kids [2 0 R]
/Count 1
/Type /Pages
>>
endobj
```
这里，对象编号是1，并且世代号是0（它几乎总是）。 
对象1的内容位于1 0 obj和endobj两行之间。 
在这种情况下，它是字典<</Kids [2 0 R] /Count 1 /Type /Pages >>

### Cross-Reference Table
交叉引用表列出了文件正文中每个对象的字节偏移量。
这允许随机访问对象，因此不必按顺序读取它们和对象
永远不会阅读从未使用过的。这尤其意味着，即使在大型文件上，
像计算PDF文档中的页数这样的简单操作也可以很快。

PDF文件中的每个对象都有一个对象编号和一个世代编号。 
当重用交叉引用表条目时使用世代号 - 我们在这里不考虑它们（它们将始终为零）。

出于我们的目的，我们可以认为交叉引用表由一个表示条目数的标题行组成，
然后是一个特殊条目，然后是文件体中每个对象的一行。 在我们的文件中：
```
0 6 Six entries in table, starting at 0
0000000000 65535 f Special entry
0000000015 00000 n Object 1 is at byte offset 15
0000000074 00000 n Object 2 is at byte offset 74
0000000192 00000 n etc...
0000000291 00000 n
0000000409 00000 n Object 5 is at byte offset 409
```
请注意，字节偏移量以前导零存储，以确保每个条目都相同
长度。因此，我们也可以通过随机访问来读取交叉引用表。

### Trailer
Trailer的第一行只是Trailer关键字。之后是Trailer
字典，至少包含/Size 条目（给出条目数在交叉引用表中）和
/Root条目（它给出了对象编号）文档目录，它是正文中对象图的根元素。

接下来是一行只包含startxref关键字，
一行包含一个数字（文件中交叉引用表开头的字节偏移量），
然后是行%%EOF，它表示PDF文件的结尾。

这是示例3-1中的Trailer：
```
trailer Trailer keyword
<< The trailer dictinonary
/Root 5 0 R
/Size 6
>>
startxref startxref keyword
459 Byte offset of cross-reference table
%%EOF End-of-file marker
```
从文件末尾向后读取Trailer：找到文件结束标记，
提取交叉引用表的字节偏移量，然后解析Trailer字典。 
Trailer关键字标记Trailer的上限。

## 词汇约定

## 对象
PDF支持五个基本对象：
* 整数和实数，例如42和3.1415
* 字符串，括在括号中，并有各种编码。 对于
例子(The Quick Brown Fox)。
* 名称，用于词典中的键，以及无数其他用途。它们带有/，例如/Blue。
* 布尔值，由关键字true和false表示。
* null对象，由关键字null表示。
和三个复合对象：
* 数组，包含其他对象的有序集合，如[1 0 0 0]。
* 字典，由无序的对集合组成，将名称映射到对象。 
例如，<</Contents 4 0 R /Resources 5 0 R >>，
其将/Contents映射到间接引用4 0 R和/Resources到间接引用5 0 R.
* 包含二进制数据的流以及描述数据属性的字典，
例如其长度和任何压缩参数。流用于存储图像，字体等。
以及将对象链接在一起的方法：
* 间接引用，它形成从一个对象到另一个对象的链接

PDF文件由对象图组成，间接引用形成它们之间的链接。例3-1的对象图如图3-1所示。

### Integers and Real Numbers
整数写为一个或多个十进制数字0..9，可选地以加号或减号开头：
```
0 +1 -1 63
```
实数被写为一个或多个十进制数字，可选地前面带有加号或减号，
并且可选地有一个小数点，可以是内部，
或以下：
```
0.0 0. .0 -0.004 65.4
```
通常，规范允许给定对象是整数或实数。其他时候它必须是整数。 
此外，整数和实数的范围和准确性由PDF实现定义，而不是标准。 
在某些实现中，如果整数超出可用范围，则将其转换为实数。

### Strings
#### Hexadecimal strings
### Names
名称在整个PDF中使用，作为字典的键和定义各种多值对象，
其中使用整数枚举它们将是不直观的。一个名字
引入正斜杠。 例如：
```
/French
```
/字符是名称的一部分 - 事实上，/它本身就是一个有效的名称。
名称可能不包含空格或分隔符，但名称需要与之对应
一些具有这些字符的外部名称（例如空格），我们可以使用哈希符号后跟两个十进制数字：
```
/Websafe#20Dark#20Green
```
这表示名称/Websafe Dark Green，因为在ASCII中，
十六进制20是空格的代码。名称区分大小写（/French和/french不同）。

### Boolean Values
### Arrays
### Dictionaries
字典表示键值对的无序集合。 字典将键映射到值 - 提供键，
值是在字典中查找的结果。 键是名称，值可以是任何PDF对象。 
字典写在<<和>>之间。 例如：
```
<</One 1 /Two 2 /Three 3>>
```
将名称/One映射到整数1，将名称/Two映射到整数2，
将名称/Three映射到整数3.字典当然可以包含其他字典。
嵌套字典构成了大多数PDF文件中的大部分非图形结构化数据。
### Indirect References 间接引用
为了将PDF内容拆分为单独的对象（因此只有在需要时才能读取数据），
我们将它们与间接引用连接在一起。对对象6的间接引用写为：


```
6 0 R
```
这里，6是对象编号，0是世代号（这里我们不考虑），R是间接参考关键字。

例如，这是使用间接引用的典型字典：
```
<< /Resources 10 0 R
 /Contents [4 0 R] >>
```
在此示例中，对象10和4在字典的值中被引用。


## Streams and Filters
流用于存储二进制数据。它们由字典和一大块二进制数据组成。
字典根据流所放置的特定用途列出数据的长度，以及可选的其他参数。

从语法上讲，流由字典组成，后跟stream关键字，
换行符（<LF>或<CR> <LF>），零个或多个字节的数据，
另一个换行符，最后是endstream关键字。 从我们的示例文件中：
```
4 0 obj Object 4
<<
/Length 65 Length of the data
>>
stream Stream keyword
1. 0. 0. 1. 50. 700. cm 65 bytes of data, here a graphics stream
BT
 /F0 36. Tf
 (Hello, World!) Tj
ET
endstream endstream keyword
endobj end of object
```
这里，字典只包含/Length条目，它以字节为单位给出流的长度。

所有流必须是间接对象。 流几乎总是使用各种机制进行压缩，如表3-3所示。
## Incremental Update 增量更新
## Object and Cross-Reference String 对象和交叉引用流
## Linearized PDF
## How a PDF File is Read
要读取PDF文件，将其从一系列平坦的字节转换为内存中对象的图形，
通常可能会发生以下步骤：
1.从文件开头读取PDF header，确认这确实是PDF文档并检索其版本号。
2.现在通过从末尾向后搜索找到文件结束标记
文件。现在可以读取trailer字典，以及开头的字节偏移量检索交叉引用表。
3.现在可以读取交叉引用表。我们现在知道每个对象在哪里了文件是。
4.在此阶段，可以读取和解析所有对象，或者我们可以离开此过程
直到实际需要每个对象，按需阅读。
5.我们现在可以使用数据，提取页面，解析图形内容，提取元数据等。
这不是详尽的描述，因为存在许多可能的复杂性（加密，线性化，对象和交叉引用流）。
psuedocode中给出的以下递归数据结构可以包含PDF对象。
## How a PDF File is Written
将PDF文档写入文件中的一系列字节要比阅读它简单得多，
我们不需要支持所有PDF格式，只需要支持我们打算使用的子集。写作
PDF文件非常快，因为它只是将对象图展平为一系列字节。
1.输出header。
2.删除PDF中任何其他对象未引用的任何对象。这个避免编写不再需要的对象。
3.重新编号对象，使它们从1到n运行，其中n是对象的数量文件。
4.逐个输出对象，从对象编号1开始，记录字节交叉引用表的每个偏移量。
5.编写交叉引用表。
6.编写trailer，trailer字典和文件结束标记
